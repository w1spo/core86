// ---------------------------
// kernel.c - 32-bit Protected Mode
// ---------------------------

#define VGA_WIDTH 80
#define VGA_HEIGHT 25
#define VGA_MEMORY ((unsigned short*)0xB8000)

#define MAX_COMMAND_LENGTH 100
#define MAX_ARGS 10

// Deklaracje funkcji
void update_cursor(void);
void outb(unsigned short port, unsigned char value);
unsigned char inb(unsigned short port);
void scroll(void);
void putchar(char c);
void print(const char* str);
void clear_screen(void);
unsigned char get_scancode(void);
char scancode_to_ascii(unsigned char sc);
void parse_command(char* cmd);
int strcmp(const char* s1, const char* s2);
void strcpy(char* dest, const char* src);
void handle_input(char c);
void prompt(void);
void kernel_init(void);

unsigned int cursor_x = 0;
unsigned int cursor_y = 0;
unsigned char color = 0x07; // biały na czarnym tle

char input_buffer[MAX_COMMAND_LENGTH];
unsigned int input_pos = 0;

// ---------------------------
// Sprzętowy kursor VGA
// ---------------------------
void update_cursor(void) {
    unsigned short pos = cursor_y * VGA_WIDTH + cursor_x;

    outb(0x3D4, 0x0F);
    outb(0x3D5, (unsigned char)(pos & 0xFF));
    outb(0x3D4, 0x0E);
    outb(0x3D5, (unsigned char)((pos >> 8) & 0xFF));
}

// Funkcje outb/inb dla 32-bit
void outb(unsigned short port, unsigned char value) {
    __asm__ volatile ("outb %0, %1" : : "a"(value), "Nd"(port));
}

unsigned char inb(unsigned short port) {
    unsigned char ret;
    __asm__ volatile ("inb %1, %0" : "=a"(ret) : "Nd"(port));
    return ret;
}

// ---------------------------
// Scroll ekranu w górę
// ---------------------------
void scroll(void) {
    if (cursor_y >= VGA_HEIGHT) {
        // Przesuń linie w górę
        for (int y = 0; y < VGA_HEIGHT - 1; y++) {
            for (int x = 0; x < VGA_WIDTH; x++) {
                VGA_MEMORY[y * VGA_WIDTH + x] = VGA_MEMORY[(y+1) * VGA_WIDTH + x];
            }
        }

        // Wyczyść ostatnią linię
        for (int x = 0; x < VGA_WIDTH; x++) {
            VGA_MEMORY[(VGA_HEIGHT-1) * VGA_WIDTH + x] = (color << 8) | ' ';
        }
        cursor_y = VGA_HEIGHT - 1;
    }
}

// ---------------------------
// Wypisanie znaku
// ---------------------------
void putchar(char c) {
    if (c == '\n') {
        cursor_x = 0;
        cursor_y++;
    } else if (c == '\r') {
        cursor_x = 0;
    } else if (c == '\b') { // Backspace
        if (cursor_x > 0) {
            cursor_x--;
            VGA_MEMORY[cursor_y * VGA_WIDTH + cursor_x] = (color << 8) | ' ';
        }
    } else {
        VGA_MEMORY[cursor_y * VGA_WIDTH + cursor_x] = (color << 8) | c;
        cursor_x++;
    }

    if (cursor_x >= VGA_WIDTH) {
        cursor_x = 0;
        cursor_y++;
    }

    scroll();
    update_cursor();
}

// ---------------------------
// Wypisanie stringa
// ---------------------------
void print(const char* str) {
    while (*str) {
        putchar(*str++);
    }
}

// ---------------------------
// Czyszczenie ekranu
// ---------------------------
void clear_screen(void) {
    for (int y = 0; y < VGA_HEIGHT; y++) {
        for (int x = 0; x < VGA_WIDTH; x++) {
            VGA_MEMORY[y * VGA_WIDTH + x] = (color << 8) | ' ';
        }
    }
    cursor_x = 0;
    cursor_y = 0;
    update_cursor();
}

// ---------------------------
// Klawiatura - odczyt scancode
// ---------------------------
unsigned char get_scancode(void) {
    // Czekaj aż klawiatura będzie gotowa
    while ((inb(0x64) & 0x01) == 0);
    return inb(0x60);
}

// ---------------------------
// Mapowanie scancode na ASCII
// ---------------------------
char scancode_to_ascii(unsigned char sc) {
    // Rozszerzone mapowanie dla QWERTY
    static const char layout[] = "??1234567890-=??qwertyuiop[]??asdfghjkl;'`?\\zxcvbnm,./??* ?";
    static const unsigned int layout_size = sizeof(layout) - 1; // -1 dla null terminator

    if (sc < layout_size) {
        char c = layout[sc];
        if (c != '?') return c;
    }

    // Specjalne klawisze
    switch(sc) {
        case 0x1C: return '\n'; // Enter
        case 0x0E: return '\b'; // Backspace
        case 0x39: return ' ';  // Space
        default:   return 0;    // Nieznany klawisz
    }
}

// ---------------------------
// Parser komend
// ---------------------------
void parse_command(char* cmd) {
    char* args[MAX_ARGS];
    int arg_count = 0;

    // Tokenizacja
    char* token = cmd;
    while (*token && arg_count < MAX_ARGS) {
        // Pomijaj spacje
        while (*token == ' ') token++;
        if (!*token) break;

        args[arg_count++] = token;

        // Znajdź koniec tokena
        while (*token && *token != ' ') token++;
        if (*token) *token++ = '\0';
    }

    if (arg_count == 0) return;

    // Wykonanie komend
    if (strcmp(args[0], "help") == 0) {
        print("Available commands:\n");
        print("help    - Show this help\n");
        print("clear   - Clear screen\n");
        print("echo    - Print text\n");
        print("version - Show kernel version\n");
    }
    else if (strcmp(args[0], "clear") == 0) {
        clear_screen();
    }
    else if (strcmp(args[0], "echo") == 0) {
        for (int i = 1; i < arg_count; i++) {
            print(args[i]);
            if (i < arg_count - 1) print(" ");
        }
        print("\n");
    }
    else if (strcmp(args[0], "version") == 0) {
        print("32-bit Protected Mode Kernel v1.0\n");
    }
    else {
        print("Unknown command: ");
        print(args[0]);
        print("\nType 'help' for available commands\n");
    }
}

// Proste funkcje string dla kernel
int strcmp(const char* s1, const char* s2) {
    while (*s1 && (*s1 == *s2)) {
        s1++;
        s2++;
    }
    return *(const unsigned char*)s1 - *(const unsigned char*)s2;
}

// Zmieniona nazwa funkcji aby uniknąć konfliktu z builtin
void kernel_strcpy(char* dest, const char* src) {
    while (*src) {
        *dest++ = *src++;
    }
    *dest = '\0';
}

// ---------------------------
// Obsługa inputu użytkownika
// ---------------------------
void handle_input(char c) {
    if (c == '\n') { // Enter
        putchar('\n');
        input_buffer[input_pos] = '\0';

        if (input_pos > 0) {
            parse_command(input_buffer);
        }

        // Reset buffer
        input_pos = 0;
        prompt();
    }
    else if (c == '\b') { // Backspace
        if (input_pos > 0) {
            input_pos--;
            putchar('\b');
        }
    }
    else if (c && input_pos < MAX_COMMAND_LENGTH - 1) { // Normalny znak
        input_buffer[input_pos++] = c;
        putchar(c);
    }
}

// ---------------------------
// Prosty prompt DOS
// ---------------------------
void prompt(void) {
    print("C:/>");
}

// ---------------------------
// Inicjalizacja
// ---------------------------
void kernel_init(void) {
    clear_screen();
    print("32-bit Protected Mode Kernel Booted Successfully!\n");
    print("Type 'help' for available commands\n\n");
    prompt();
}

// ---------------------------
// Kernel main
// ---------------------------
void kernel_main(void) {
    kernel_init();

    while (1) {
        unsigned char sc = get_scancode();
        if (sc & 0x80) continue; // ignorujemy release

        char c = scancode_to_ascii(sc);
        if (c) {
            handle_input(c);
        }
    }
}
